"""
Description:
Simple script to attempt to dump a JSON web token after decoding it. Note that
the signature is decoded and dumped as hexadecimal values. For more information
on the security of JSON web tokens refer to;
https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/

Example:
  * python ./web-json-web-token.py -d eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJsb2dnZWRJbkFzIjoiYWRtaW4iLCJpYXQiOjE0MjI3Nzk2Mzh9.gzSraSYS8EXBxLN_oWnFSRgCzcmJmMjLiuyu5CSpyHI
  * python ./web-json-web-token.py -e "{"alg":"HS256","typ":"JWS"}.{"login":"test","iat":"1488505862"}.2a7aef5fd4618076f4aeeae9fcd3b995997e2309a6a69bdf56ea927a74442117"

Known Issues:
  * 

Todo:
  * Implement signature calculation using key
  * Implement signature verification using key
"""

import base64
import json
import optparse
import sys


# Global (module) variables


def print_usage():
  """
  Prints the usage information

  Args:
    None

  Yields:
    None

  Returns:
    None
  """

  print "usage:"
  print "python", sys.argv[0], "-d <jwt> | -e '<jst>'"
  print "  jwt - the base64 encode JSON web token"
  print "  jst - string representing json 'header.payload.signature'"


def print_encoded( jst ):
  """
  Prints the encoded JSON web token 

  Args:
    jst - the string concatenating the header.payload.signature

  Yields:
    None

  Returns:
    None
  """

  (header, dot, payload_signature) = jst.partition('.')
  if header == jst:
    print "[invalid jst]"
    return

  header = get_encoded( header )

  (payload, dot, signature) = payload_signature.partition('.')
  payload = get_encoded( payload );
  if payload == payload_signature:
    signature = ""
  else:
    signature = get_encoded( signature )

  print header + "." + payload + "." + signature


def print_decoded( jwt ):
  """
  Prints the decoded JSON web token

  Args:
    jwt - the JSON web token

  Yields:
    None

  Returns:
    None
  """

  # get and print token header
  (header, dot, payload_signature) = jwt.partition('.')
  if header == jwt:
    print "[invalid jwt]"
    return

  print "header: " + get_decoded( header )

  # get and print payload and optionally the signature
  (payload, dot, signature) = payload_signature.partition('.')
  print "payload: " + get_decoded( payload );
  if payload == payload_signature:
    print "signature: <no signature present>"
    return
  else:
    print "signature: " + get_decoded(signature)


def get_encoded( js ):
  """
  Returns a string containing the base64 encoded value of the json string or a
  string containing an error message.

  Args: 
    js - string representing JSON object

  Yields:
    None

  Returns:
    String containing the base64 encoded value or an error message
  """

  if js == None or not js:
    return "<empty>"

  json.dumps(js)

  return base64.urlsafe_b64encode( js )
  


def get_decoded( claim ):
  """
  Returns a string containing the base64 decoded value of the claim or a string
  containing an error message.

  Args: 
    claim - base64 encoded JSON object

  Yields:
    None

  Returns:
    String containing the base64 decoded value of the claim or an error message
  """

  if claim == None or not claim:
    return "<empty>"
  elif (len( claim ) % 3) > 0:
    claim += "===" # https://tools.ietf.org/html/rfc3548.html

  try: 
    return base64.urlsafe_b64decode( claim )
  except TypeError as te:
    return "[bad pad]" # should never happen cos we pad good


#
# Main entry point
#

# Check parameters
try:
  if (len( sys.argv )) != 3:
    print "error: invalid arguments"
    print_usage()
    sys.exit()

  elif sys.argv[1] == "-d":
    jwt = sys.argv[2]
    # TODO: validate token here, min length, #delimiters, etc.
    print_decoded( jwt )

  elif sys.argv[1] == '-e':
    jst = sys.argv[2]
    print_encoded( jst )

  else:
    print "error: invalid arguments"
    print_usage()
    sys.exit()
    
except Exception as e:
  print sys.exc_info()
  sys.exit()

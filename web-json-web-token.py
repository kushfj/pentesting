#!/usr/bin/env python3

"""
Description:
Simple script to attempt to dump a JSON web token after decoding it. Note that
the signature is decoded and dumped as hexadecimal values. For more information
on the security of JSON web tokens refer to;
https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/

Example:
  * python ./web-json-web-token.py -d eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJsb2dnZWRJbkFzIjoiYWRtaW4iLCJpYXQiOjE0MjI3Nzk2Mzh9.gzSraSYS8EXBxLN_oWnFSRgCzcmJmMjLiuyu5CSpyHI
  * python ./web-json-web-token.py -e "{"alg":"HS256","typ":"JWS"}.{"login":"test","iat":"1488505862"}

Known Issues:
  * 

Todo:
  * Implement signature calculation using key
  * Implement signature verification using key
"""

import base64
import binascii
import json
import sys


# Global (module) variables


def is_valid_str(s: str) -> bool:
  if s is None:
    return False
  elif not s:
    return False
  elif s.strip() == "":
    return False

  return True


def print_usage():
  """
  Prints the usage information

  Args:
    None

  Yields:
    None

  Returns:
    None
  """

  print("usage:")
  print("python", sys.argv[0], "-d <jwt> | -e '<jst>'")
  print("  -d jwt - decode the base64 encoded JSON web token")
  print("  -j jwt - print the base64 encoded JSON web token as a JWT for cracking with JtR (John the Ripper)")
  print("  -e jst - encode string representing json 'header.payload.signature'")


def print_encoded(jst:str):
  """
  Prints the encoded JSON web token 

  Args:
    jst - the string concatenating the header.payload.signature

  Yields:
    None

  Returns:
    None
  """

  if not is_valid_str(jst):
    return

  parts = jst.split(".",1)
  if len(parts) != 2:
    print("[!] invalid jst: {0}".format(jst))
    return

  header = parts[0]
  payload = parts[1]

  if not is_valid_str(header) or not is_valid_str(payload):
    print("[!] invalid jst")

  header = get_encoded( header )
  payload = get_encoded( payload );
  signature = compute_signature(header, payload)

  print(header+"."+payload+"."+signature)


def compute_signature(header:str, payload:str) -> str:
  """
  TODO
  """
  if not is_valid_str(header) or not is_valid_str(payload):
    return ""

  json_header = None
  json_payload = None

  try:
    json_header = json.loads(header)
  except:
    return ""

  alg = json_header['alg']
  if alg.lower() == 'none':
    return ""
  elif alg.lower() == 'hs256':
    return "TODO:hs256"
  else:
    print("[-] algorithm not supported: {0}".format(alg))
    return ""


def print_jtr(jwt):
  """
  Print the decoded JSON web token in a format suitable for cracking with john 
  the ripper. The header and payload are printed as base64 encoded values 
  separated by a persion(.) and the signature is separated from the header and 
  payload with a hash or pound symbol (#). The signature is printed as 
  hexadecimal representation of the binary signature data.

  Args:
    jwt - the JSON web token

  Yields: 
    None

  Returns:
    None
  """
  if not is_valid_str(jwt):
    return
  print_decoded(jwt, "jtr")


def print_decoded(jwt: str, format="default"):
  """
  Prints the decoded JSON web token

  Args:
    jwt - the JSON web token

  Yields:
    None

  Returns:
    None
  """
  if not is_valid_str(jwt):
    print("[!] invalid jwt")
    return

  parts = jwt.split(".",2)
  if len(parts) != 3:
    print("[!] invalid jwt: {0}".format(jwt))
    return

  header = parts[0]
  payload = parts[1]
  signature = parts[2]

  if format == "jtr":
    # print in format suitable for use with john the ripper
    print(header+"."+payload+"#"+get_decoded(signature))

  else:
    # print in default format
    print_jwt(header, payload, signature)


def print_jwt(header="", payload="", signature=""):
  print("header: "+get_decoded(header))
  print("payload: "+get_decoded(payload))
  print("signature: "+get_decoded(signature))


def get_encoded(js) -> str:
  """
  Returns a string containing the base64 encoded value of the json string or a
  string containing an error message.

  Args: 
    js - string representing JSON object

  Yields:
    None

  Returns:
    String containing the base64 encoded value or an error message
  """
  if not is_valid_str(js):
    return ""
  #json.dumps(js)
  # need to validate json and return encoded here
  return base64.urlsafe_b64encode(js)
  

def get_decoded(claim="") -> str:
  """
  Returns a string containing the base64 encoded value of the claim or if the 
  base64 decoded value cannot be represented as an ASCII string then returns 
  the hexadecimal string representing the claim or an empty string if the 
  claim cannot be decoded.

  Args: 
    claim - base64 encoded JSON object

  Yields:
    None

  Returns:
    String containing the decoded value of the claim or an empty string
  """
  if not is_valid_str(claim):
    return ""

  # pad the claim if not properly padded
  elif (len(claim) % 3) > 0:
    claim += "===" # https://tools.ietf.org/html/rfc3548.html

  # decode the claim
  try: 
    return base64.urlsafe_b64decode(claim).decode("utf-8")
  except UnicodeDecodeError:
    return binascii.hexlify(base64.urlsafe_b64decode(claim)).decode("utf-8")
  except:
    print("[!] unable to decode claim: {0}".format(claim))
    return ""


#
# Main entry point
#

def main():
  # Check parameters
  if (len(sys.argv)) != 3:
    print_usage()
    sys.exit()

  elif sys.argv[1] == "-d":
    jwt = sys.argv[2]
    print_decoded(jwt)

  elif sys.argv[1] == "-j":
    print_jtr(sys.argv[2])

  elif sys.argv[1] == '-e':
    jst = sys.argv[2]
    print_encoded(jst)

  else:
    print_usage()
    sys.exit()


if __name__ == "__main__":
  main()
